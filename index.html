<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>!Hey</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css">
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Anna Powaska">
    <meta name="description" content="Anna Powaska">
    <link rel="icon" href="/images/150252110.png">
      <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; max-width: 900px; margin: 20px auto; padding: 0 10px; }
    h1, h2, h3 { color: #333; }
    .example { background: #f5f5f5; padding: 10px; border-left: 4px solid #999; margin: 10px 0; }
    .question { margin: 15px 0; padding: 10px; border: 1px solid #ddd; }
    .answers li { margin: 3px 0; }
    .correct { color: green; font-weight: bold; }
    .note { font-size: 0.9em; color: #555; }
  </style>

</head>
<body>
  <h2>4.2 Czarnoskrzynkowe techniki testowania — o co chodzi?</h2>

<p>
  Czarnoskrzynkowe techniki testowania polegają na sprawdzaniu <strong>zachowania systemu</strong>
  na podstawie wejść i wyjść — bez zaglądania do kodu.  
  W ISTQB wyróżniamy cztery główne techniki:
</p>

<ul>
  <li>podział na klasy równoważności,</li>
  <li>analiza wartości brzegowych,</li>
  <li>tablice decyzyjne,</li>
  <li>testowanie przejść między stanami.</li>
</ul>

<hr />

<h2>4.2.1 Podział na klasy równoważności</h2>

<p>
  Jedna z najprostszych i najczęściej używanych technik czarnoskrzynkowych.
  Jej celem jest ograniczenie liczby testów poprzez grupowanie danych wejściowych
  w <strong>klasy równoważności</strong>, czyli zbiory wartości, które system traktuje tak samo.
</p>

<h3>Na czym polega technika?</h3>

<p>
  Zamiast testować każdą możliwą wartość, dzielisz dane na klasy, w których:
</p>

<ul>
  <li>system zachowuje się identycznie,</li>
  <li>jeśli jedna wartość z klasy wykryje błąd — każda inna też by go wykryła.</li>
</ul>

<p>
  Dlatego z każdej klasy wybierasz <strong>tylko jeden reprezentatywny test</strong>.
</p>

<h3>Rodzaje klas równoważności</h3>

<ul>
  <li><strong>Poprawne</strong> — system powinien je zaakceptować.</li>
  <li><strong>Niepoprawne</strong> — system powinien je odrzucić lub zgłosić błąd.</li>
</ul>

<p>Klasy muszą być:</p>
<ul>
  <li>rozłączne (nie mogą się nakładać),</li>
  <li>niepuste,</li>
  <li>kompletne (obejmują cały zakres możliwych danych).</li>
</ul>

<h3>Co można dzielić na klasy?</h3>

<ul>
  <li>wejścia (np. wiek, kwota, login),</li>
  <li>wyjścia,</li>
  <li>konfiguracje,</li>
  <li>wartości zależne od czasu,</li>
  <li>parametry interfejsu.</li>
</ul>

<h3>Wiele parametrów?</h3>

<p>
  Każdy parametr ma własne klasy równoważności.  
  Najprostsze kryterium pokrycia to <strong>each choice</strong> — każda klasa z każdego parametru
  musi być przetestowana przynajmniej raz.
</p>

<hr />

<h3>Przykład 1 — klasyczny ISTQB (wiek)</h3>

<p><strong>Wymaganie:</strong> System akceptuje wiek od 18 do 65 lat.</p>

<h4>1️⃣ Tworzymy klasy równoważności</h4>

<table border="1" cellpadding="6">
  <tr><th>Typ klasy</th><th>Zakres</th><th>Opis</th></tr>
  <tr><td>Poprawna</td><td>18–65</td><td>Wiek prawidłowy</td></tr>
  <tr><td>Niepoprawna</td><td>&lt;18</td><td>Za młody</td></tr>
  <tr><td>Niepoprawna</td><td>&gt;65</td><td>Za stary</td></tr>
</table>

<h4>2️⃣ Wybieramy po jednym przykładzie</h4>

<ul>
  <li>30 — poprawna klasa,</li>
  <li>10 — za młody,</li>
  <li>80 — za stary.</li>
</ul>

<h4>3️⃣ Przypadki testowe</h4>

<table border="1" cellpadding="6">
  <tr><th>Test</th><th>Wartość</th><th>Oczekiwany wynik</th></tr>
  <tr><td>1</td><td>30</td><td>Formularz akceptuje</td></tr>
  <tr><td>2</td><td>10</td><td>Błąd: wiek za niski</td></tr>
  <tr><td>3</td><td>80</td><td>Błąd: wiek za wysoki</td></tr>
</table>

<hr />

<h3>Przykład 2 — bardziej „życiowy” (kwota przelewu)</h3>

<p><strong>Wymaganie:</strong></p>
<ul>
  <li>Kwota przelewu: 1–10 000 PLN,</li>
  <li>musi być liczbą całkowitą.</li>
</ul>

<h4>Klasy:</h4>

<ul>
  <li>Poprawna: 1–10 000</li>
  <li>Niepoprawna: &lt;1</li>
  <li>Niepoprawna: &gt;10 000</li>
  <li>Niepoprawna: nie‑liczba (np. tekst, puste pole)</li>
</ul>

<h4>Przykładowe wartości:</h4>

<ul>
  <li>500</li>
  <li>0</li>
  <li>20 000</li>
  <li>"abc"</li>
</ul>

<hr />

<h3>Pokrycie klas równoważności</h3>

<p>
  Pokrycie = (liczba klas, które mają przynajmniej jeden test) / (liczba wszystkich klas) × 100%
</p>

<h4>Przykład:</h4>

<p>Klasy dla wieku:</p>
<ul>
  <li>&lt;18 — niepoprawna</li>
  <li>18–65 — poprawna</li>
  <li>&gt;65 — niepoprawna</li>
</ul>

<p>Testy:</p>
<ul>
  <li>20 → pokrywa klasę poprawną</li>
  <li>10 → pokrywa klasę &lt;18</li>
</ul>

<p>Brakuje testu dla &gt;65.</p>

<p><strong>Pokrycie = 2/3 × 100% = 66,6%</strong></p>

<hr />

<h2>Pytania testowe (A–D)</h2>

<div class="question">
  <p><strong>1. Co jest główną ideą podziału na klasy równoważności?</strong></p>
  <ul class="answers">
    <li>A. Testowanie wszystkich możliwych wartości wejściowych</li>
    <li>B. Grupowanie danych w zbiory zachowujące się tak samo</li>
    <li>C. Testowanie tylko wartości brzegowych</li>
    <li>D. Testowanie kodu źródłowego</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>2. Która z poniższych cech NIE dotyczy klas równoważności?</strong></p>
  <ul class="answers">
    <li>A. Muszą być rozłączne</li>
    <li>B. Mogą na siebie nachodzić</li>
    <li>C. Nie mogą być puste</li>
    <li>D. Powinny obejmować cały zakres danych</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>3. Co oznacza kryterium each choice?</strong></p>
  <ul class="answers">
    <li>A. Testujemy wszystkie możliwe kombinacje wartości</li>
    <li>B. Każda klasa z każdego parametru musi być przetestowana przynajmniej raz</li>
    <li>C. Testujemy tylko wartości brzegowe</li>
    <li>D. Testujemy tylko klasy poprawne</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>4. Ile testów minimalnie potrzeba dla 4 klas równoważności?</strong></p>
  <ul class="answers">
    <li>A. 1</li>
    <li>B. 2</li>
    <li>C. 3</li>
    <li>D. 4</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: D</p>
</div>

<div class="question">
  <p><strong>5. Co oznacza pokrycie klas równoważności?</strong></p>
  <ul class="answers">
    <li>A. Liczbę testów automatycznych</li>
    <li>B. Procent klas, które mają przynajmniej jeden test</li>
    <li>C. Liczbę defektów wykrytych w klasach</li>
    <li>D. Liczbę parametrów wejściowych</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>


<p>
Technika analizy wartości brzegowych polega na testowaniu wartości znajdujących się na granicach 
klas równoważności. Można ją stosować tylko wtedy, gdy klasy są uporządkowane (np. liczby, daty). 
Wartościami brzegowymi są minimalna i maksymalna wartość klasy.
</p>

<p>
Założenie tej techniki jest proste: jeśli dwa elementy należą do tej samej klasy, to wszystkie wartości 
pomiędzy nimi również do niej należą. Programiści najczęściej popełniają błędy właśnie na granicach, 
dlatego testowanie brzegów jest bardzo skuteczne.
</p>

<h3>Warianty analizy wartości brzegowych</h3>

<h4>1. Dwupunktowa analiza wartości brzegowych</h4>
<p>
Dla każdej wartości brzegowej sprawdzamy:
</p>
<ul>
  <li>samą wartość brzegową,</li>
  <li>najbliższą wartość z sąsiedniej klasy.</li>
</ul>
<p>
Oznacza to 2 testy na jedną granicę. Pokrycie liczy się jako:
<br>
<strong>(liczba sprawdzonych wartości brzegowych) / (liczba wszystkich wartości brzegowych)</strong>.
</p>

<h4>2. Trójpunktowa analiza wartości brzegowych</h4>
<p>
Dla każdej wartości brzegowej sprawdzamy:
</p>
<ul>
  <li>wartość poniżej,</li>
  <li>wartość brzegową,</li>
  <li>wartość powyżej.</li>
</ul>
<p>
Oznacza to 3 testy na jedną granicę. Pokrycie liczy się jako:
<br>
<strong>(liczba sprawdzonych wartości brzegowych i sąsiednich) / (łączna liczba tych wartości)</strong>.
</p>

<p>
Trójpunktowa analiza jest bardziej rygorystyczna i wykrywa błędy, które mogą zostać pom
    <h2>Przykład — najprostszy i najbardziej ISTQB‑owy</h2>

<h3>Wymaganie</h3>
<p>System akceptuje wiek od 18 do 65.</p>

<h3>Granice</h3>
<ul>
  <li>Dolna: <strong>18</strong></li>
  <li>Górna: <strong>65</strong></li>
</ul>

<h3>Dwupunktowa analiza (2‑point)</h3>
<p>Dla granicy 18:</p>
<ul>
  <li>18 (wartość brzegowa)</li>
  <li>17 (wartość z sąsiedniej klasy)</li>
</ul>

<p>Dla granicy 65:</p>
<ul>
  <li>65</li>
  <li>66</li>
</ul>

<p><strong>Łącznie: 4 testy</strong></p>

<h3>Trójpunktowa analiza (3‑point)</h3>
<p>Dla granicy 18:</p>
<ul>
  <li>17 (poniżej)</li>
  <li>18 (brzeg)</li>
  <li>19 (powyżej)</li>
</ul>

<p>Dla granicy 65:</p>
<ul>
  <li>64</li>
  <li>65</li>
  <li>66</li>
</ul>

<p><strong>Łącznie: 6 testów</strong></p>

<h3>Dlaczego analiza trójpunktowa jest lepsza?</h3>

<p>Przykład z sylabusa:</p>

<p>Programista miał napisać:</p>
<pre><code>if (x ≤ 10)
</code></pre>

<p>A napisał:</p>
<pre><code>if (x = 10)
</code></pre>

<p>Dwupunktowa analiza da testy:</p>
<ul>
  <li>10</li>
  <li>11</li>
</ul>

<p>Oba mogą przejść, więc błąd się nie ujawni.</p>

<p>Trójpunktowa analiza da także:</p>
<ul>
  <li>9</li>
</ul>

<p>I wtedy błąd zostanie wykryty.</p>

<h3>Pytanie testowe</h3>

<p><strong>Pytanie:</strong><br> System akceptuje kwotę przelewu od 100 do 5000 PLN.<br> Który zestaw danych testowych odpowiada <strong>dwupunktowej analizie wartości brzegowych</strong>? </p> <ol type="A"> <li>100, 101, 4999, 5000</li> <li>99, 100, 5000, 5001</li> <li>100, 5000</li> <li>99, 101, 4999, 5001</li> </ol> <p><strong>Prawidłowa odpowiedź: B</strong></p> <p><strong>Dlaczego?</strong><br> Dwupunktowa analiza = wartość brzegowa + wartość z sąsiedniej klasy: </p> <ul> <li>Dolna granica: 100 i 99</li> <li>Górna granica: 5000 i 5001</li> </ul>
<h2>4.2.3 Testowanie w oparciu o tablicę decyzyjną</h2>

<p>
Testowanie oparte na tablicy decyzyjnej polega na analizie tego, jak różne kombinacje warunków 
wpływają na wynik działania systemu. Tablice decyzyjne świetnie nadają się do testowania złożonych 
reguł biznesowych, gdzie wiele warunków może prowadzić do różnych akcji.
</p>

<p>
Każda tablica decyzyjna składa się z:
</p>
<ul>
  <li><strong>warunków</strong> – co musi być spełnione,</li>
  <li><strong>akcji</strong> – co system powinien zrobić,</li>
  <li><strong>kolumn</strong> – każda kolumna to jedna reguła decyzyjna (kombinacja warunków).</li>
</ul>

<p>
Wartości w tablicy mogą być:
</p>
<ul>
  <li><strong>P</strong> – warunek spełniony (true),</li>
  <li><strong>F</strong> – warunek niespełniony (false),</li>
  <li><strong>—</strong> – wartość nieistotna dla danej reguły,</li>
  <li><strong>nd</strong> – nie dotyczy,</li>
  <li><strong>X</strong> – akcja powinna zostać wykonana,</li>
  <li><strong>puste pole</strong> – akcja nie powinna zostać wykonana.</li>
</ul>

<p>
Pełna tablica decyzyjna zawiera wszystkie możliwe kombinacje warunków. Można ją uprościć, 
usuwając kombinacje niemożliwe lub scalając kolumny, w których część warunków nie ma wpływu 
na wynik.
</p>

<p>
W tej technice elementami pokrycia są <strong>kolumny</strong> (reguły decyzyjne). 
Aby uzyskać 100% pokrycia, należy przetestować każdą możliwą do spełnienia kolumnę.
</p>

<hr>

<h3>Przykład</h3>

<p>
System przyznaje rabat według reguł:
</p>

<ul>
  <li>Warunek A: Klient ma kartę stałego klienta.</li>
  <li>Warunek B: Klient zrobił zakupy powyżej 200 zł.</li>
</ul>

<p>Akcja: Przyznaj rabat.</p>

<p>Tablica decyzyjna:</p>

<table border="1" cellpadding="6">
  <tr>
    <th>Warunek A</th>
    <th>Warunek B</th>
    <th>Akcja: Rabat</th>
  </tr>
  <tr>
    <td>P</td>
    <td>P</td>
    <td>X</td>
  </tr>
  <tr>
    <td>P</td>
    <td>F</td>
    <td>X</td>
  </tr>
  <tr>
    <td>F</td>
    <td>P</td>
    <td>X</td>
  </tr>
  <tr>
    <td>F</td>
    <td>F</td>
    <td></td>
  </tr>
</table>

<p>
Interpretacja: rabat jest przyznawany, jeśli spełniony jest przynajmniej jeden warunek.
</p>

<hr>

<h3>Pytania testowe</h3>

<ol>
  <li>
    Co reprezentuje jedna kolumna w tablicy decyzyjnej?
  </li>
  <li>
    Który symbol oznacza, że warunek nie ma znaczenia dla danej reguły?
  </li>
  <li>
    Co jest elementem pokrycia w testowaniu opartym na tablicy decyzyjnej?
  </li>
</ol>

<h3>Odpowiedzi i wyjaśnienia</h3>

<ul>
  <li>
    <strong>1.</strong> Kolumna to jedna <strong>reguła decyzyjna</strong>, czyli unikatowa kombinacja warunków i akcji.
  </li>
  <li>
    <strong>2.</strong> Symbol <strong>—</strong> oznacza, że warunek jest nieistotny dla wyniku.
  </li>
  <li>
    <strong>3.</strong> Elementem pokrycia są <strong>kolumny</strong> zawierające możliwe do spełnienia kombinacje warunków.
  </li>
</ul>
<h2>4.2.4 Testowanie przejść pomiędzy stanami</h2>

<p>
Testowanie przejść pomiędzy stanami polega na analizie, jak system zmienia swój stan w odpowiedzi 
na różne zdarzenia. Do modelowania zachowania systemu używa się <strong>diagramów stanów</strong> lub 
<strong>tablic stanów</strong>. Każdy stan reprezentuje określoną sytuację systemu, a przejścia pokazują, jak 
system reaguje na zdarzenia.
</p>

<p>
Przejście ma zwykle postać: <strong>zdarzenie [warunek] / akcja</strong>.  
Warunek i akcja mogą być pominięte, jeśli nie są istotne.
</p>

<p>
Tablica stanów jest alternatywną formą diagramu.  
Wiersze = stany, kolumny = zdarzenia.  
Komórki = wynik przejścia (stan docelowy + ewentualna akcja).  
Puste komórki oznaczają <strong>niepoprawne przejścia</strong>.
</p>

<p>
Przypadki testowe w tej technice to sekwencje zdarzeń, które powodują przejścia między stanami. 
Jeden test może pokrywać wiele przejść.
</p>

<hr>

<h3>Kryteria pokrycia</h3>

<ul>
  <li><strong>Pokrycie wszystkich stanów</strong> – testy muszą odwiedzić każdy stan przynajmniej raz.</li>
  <li><strong>Pokrycie poprawnych przejść (0-przełączeń)</strong> – testy muszą wykonać każde poprawne przejście.</li>
  <li><strong>Pokrycie wszystkich przejść</strong> – testy muszą wykonać wszystkie poprawne przejścia oraz podjąć próbę wykonania przejść niepoprawnych.</li>
</ul>

<p>
Pokrycie wszystkich przejść jest najsilniejszym kryterium, ponieważ obejmuje zarówno stany, jak i przejścia poprawne oraz niepoprawne.
</p>

<hr>

<h3>Przykład</h3>

<p>
System drzwi automatycznych ma trzy stany:
</p>

<ul>
  <li><strong>Zamknięte</strong></li>
  <li><strong>Otwieranie</strong></li>
  <li><strong>Otwarte</strong></li>
</ul>

<p>
Zdarzenia:
</p>

<ul>
  <li><strong>sensor</strong> – wykryto osobę</li>
  <li><strong>timeout</strong> – minął czas otwarcia</li>
</ul>

<p>Tablica stanów:</p>

<table border="1" cellpadding="6">
  <tr>
    <th>Stan</th>
    <th>sensor</th>
    <th>timeout</th>
  </tr>
  <tr>
    <td>Zamknięte</td>
    <td>Otwieranie</td>
    <td></td>
  </tr>
  <tr>
    <td>Otwieranie</td>
    <td>Otwarte</td>
    <td></td>
  </tr>
  <tr>
    <td>Otwarte</td>
    <td></td>
    <td>Zamknięte</td>
  </tr>
</table>

<p>
Przykładowa sekwencja testowa pokrywająca wszystkie poprawne przejścia:
</p>

<pre>
Zamknięte --sensor--> Otwieranie --sensor--> Otwarte --timeout--> Zamknięte
</pre>

<hr>

<h3>Pytania testowe</h3>

<ol>
  <li>
    Co oznacza pusta komórka w tablicy stanów?
  </li>
  <li>
    Które kryterium pokrycia jest najsilniejsze?
  </li>
  <li>
    Co jest elementem pokrycia w kryterium „pokrycie poprawnych przejść”?
  </li>
</ol>

<h3>Odpowiedzi i wyjaśnienia</h3>

<ul>
  <li>
    <strong>1.</strong> Pusta komórka oznacza <strong>niepoprawne przejście</strong>, którego system nie powinien wykonywać.
  </li>
  <li>
    <strong>2.</strong> <strong>Pokrycie wszystkich przejść</strong> – obejmuje stany, przejścia poprawne i próby przejść niepoprawnych.
  </li>
  <li>
    <strong>3.</strong> Elementem pokrycia są <strongwszystkie poprawne przejścia</strong> między stanami.
  </li>
</ul>
<h3>Przykład – Bankomat (ATM)</h3>

<p>
Bankomat może znajdować się w jednym z trzech stanów:
</p>

<ul>
  <li><strong>Idle</strong> – oczekiwanie na kartę</li>
  <li><strong>Card Inserted</strong> – karta włożona, oczekiwanie na PIN</li>
  <li><strong>Authenticated</strong> – PIN poprawny, użytkownik może wykonywać operacje</li>
</ul>

<p>
Zdarzenia:
</p>

<ul>
  <li><strong>insert_card</strong> – użytkownik wkłada kartę</li>
  <li><strong>enter_pin_ok</strong> – użytkownik wpisuje poprawny PIN</li>
  <li><strong>enter_pin_fail</strong> – użytkownik wpisuje błędny PIN</li>
  <li><strong>remove_card</strong> – użytkownik wyciąga kartę</li>
</ul>

<p>Tablica stanów:</p>

<table border="1" cellpadding="6">
  <tr>
    <th>Stan</th>
    <th>insert_card</th>
    <th>enter_pin_ok</th>
    <th>enter_pin_fail</th>
    <th>remove_card</th>
  </tr>

  <tr>
    <td>Idle</td>
    <td>Card Inserted</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>

  <tr>
    <td>Card Inserted</td>
    <td></td>
    <td>Authenticated</td>
    <td>Idle</td>
    <td>Idle</td>
  </tr>

  <tr>
    <td>Authenticated</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Idle</td>
  </tr>
</table>

<p>
Przykładowa sekwencja testowa pokrywająca wszystkie poprawne przejścia:
</p>

<pre>
Idle --insert_card--> Card Inserted 
Card Inserted --enter_pin_ok--> Authenticated 
Authenticated --remove_card--> Idle
</pre>

<p>
Przykład testu niepoprawnego przejścia (powinien zostać odrzucony):
</p>

<pre>
Idle --enter_pin_ok--> (niepoprawne przejście)
</pre>

<hr>

<h3>Pytania testowe</h3>

<ol>
  <li>
    Co oznacza pusta komórka w tablicy stanów bankomatu?
  </li>
  <li>
    Jakie kryterium pokrycia wymaga wykonania zarówno poprawnych, jak i niepoprawnych przejść?
  </li>
  <li>
    Jaki będzie wynik zdarzenia <strong>enter_pin_fail</strong> w stanie <strong>Card Inserted</strong>?
  </li>
</ol>

<h3>Odpowiedzi i wyjaśnienia</h3>

<ul>
  <li>
    <strong>1.</strong> Pusta komórka oznacza <strong>niepoprawne przejście</strong>, którego system nie powinien wykonać.
  </li>
  <li>
    <strong>2.</strong> <strong>Pokrycie wszystkich przejść</strong> – obejmuje przejścia poprawne i próby wykonania niepoprawnych.
  </li>
  <li>
    <strong>3.</strong> System wróci do stanu <strong>Idle</strong> (błędny PIN powoduje odrzucenie karty).
  </li>
</ul>
<h2>4.3 Białoskrzynkowe techniki testowania</h2>

<p>
Techniki białoskrzynkowe polegają na projektowaniu testów na podstawie <strong>struktury kodu</strong>. 
Tester zna wewnętrzną logikę programu i tworzy przypadki testowe tak, aby pokryć określone elementy kodu.
</p>

<p>
W sylabusie skupiamy się na dwóch podstawowych technikach:
</p>

<ul>
  <li><strong>Testowanie instrukcji</strong></li>
  <li><strong>Testowanie gałęzi</strong></li>
</ul>

<p>
Istnieją bardziej zaawansowane techniki (np. pokrycie ścieżek, pokrycie warunków, pokrycie decyzji), 
ale nie są one wymagane na poziomie podstawowym ISTQB.
</p>

<hr>

<!-- 4.3.1 -->
<h3>4.3.1 Testowanie instrukcji i pokrycie instrukcji kodu</h3>

<p>
W testowaniu instrukcji elementami pokrycia są <strong>wszystkie wykonywalne instrukcje</strong> w kodzie. 
Celem jest wykonanie każdej instrukcji przynajmniej raz.
</p>

<p>
Pokrycie instrukcji mierzy się jako:
</p>

<pre>
pokrycie = (liczba wykonanych instrukcji / liczba wszystkich instrukcji) × 100%
</pre>

<p>
100% pokrycia instrukcji oznacza, że każda linia kodu została wykonana, ale <strong>nie oznacza</strong>, 
że przetestowano wszystkie możliwe ścieżki logiczne.
</p>

<h4>Przykład</h4>

<pre>
1: x = 10
2: if (x > 5):
3:     print("duże")
4: print("koniec")
</pre>

<p>
Test: x = 10  
Pokryte instrukcje: 1, 2, 3, 4 → pokrycie 100%.
</p>

<p>
Ale nie sprawdziliśmy przypadku, gdy warunek jest fałszywy — dlatego logika nie została w pełni przetestowana.
</p>

<h4>Pytania testowe</h4>

<ol>
  <li>Co jest elementem pokrycia w testowaniu instrukcji?</li>
  <li>Czy 100% pokrycia instrukcji gwarantuje pełne przetestowanie logiki?</li>
  <li>Dlaczego testowanie instrukcji może nie wykryć wszystkich defektów?</li>
</ol>

<h4>Odpowiedzi i wyjaśnienia</h4>

<ul>
  <li><strong>1.</strong> Wszystkie wykonywalne instrukcje w kodzie.</li>
  <li><strong>2.</strong> Nie — bo nie sprawdza wszystkich gałęzi i ścieżek.</li>
  <li><strong>3.</strong> Bo niektóre defekty ujawniają się tylko przy konkretnych danych lub ścieżkach.</li>
</ul>

<hr>

<!-- 4.3.2 -->
<h3>4.3.2 Testowanie gałęzi i pokrycie gałęzi</h3>

<p>
Gałąź to możliwy przepływ sterowania w kodzie — np. wynik decyzji <strong>IF</strong>, wybór w <strong>SWITCH</strong>, 
lub przejście w pętli.  
W testowaniu gałęzi elementami pokrycia są <strong>wszystkie gałęzie</strong> (zarówno „prawda”, jak i „fałsz”).
</p>

<p>
Pokrycie gałęzi mierzy się jako:
</p>

<pre>
pokrycie = (liczba wykonanych gałęzi / liczba wszystkich gałęzi) × 100%
</pre>

<p>
100% pokrycia gałęzi oznacza, że wykonano wszystkie możliwe przejścia sterowania.  
Pokrycie gałęzi <strong>subsumuje</strong> pokrycie instrukcji — czyli jeśli masz 100% gałęzi, masz też 100% instrukcji.
</p>

<h4>Przykład</h4>

<pre>
1: if (x > 5):
2:     print("duże")
3: else:
4:     print("małe")
</pre>

<p>
Gałęzie:
</p>

<ul>
  <li>warunek TRUE → linia 2</li>
  <li>warunek FALSE → linia 4</li>
</ul>

<p>
Aby mieć 100% pokrycia gałęzi, potrzebujesz dwóch testów:
</p>

<ul>
  <li>x = 10 → TRUE</li>
  <li>x = 3 → FALSE</li>
</ul>

<h4>Pytania testowe</h4>

<ol>
  <li>Co jest elementem pokrycia w testowaniu gałęzi?</li>
  <li>Ile testów potrzeba, aby pokryć gałęzie w instrukcji IF/ELSE?</li>
  <li>Czy pokrycie gałęzi gwarantuje pokrycie instrukcji?</li>
</ol>

<h4>Odpowiedzi i wyjaśnienia</h4>

<ul>
  <li><strong>1.</strong> Wszystkie gałęzie przepływu sterowania (TRUE/FALSE, CASE itp.).</li>
  <li><strong>2.</strong> Minimum dwa — jeden dla TRUE, jeden dla FALSE.</li>
  <li><strong>3.</strong> Tak — pokrycie gałęzi subsumuje pokrycie instrukcji.</li>
</ul>

<hr>

<!-- 4.3.3 -->
<h3>4.3.3 Korzyści wynikające z testowania białoskrzynkowego</h3>

<p>
Techniki białoskrzynkowe pozwalają testować <strong>rzeczywistą implementację</strong>, a nie tylko wymagania. 
Dzięki temu można wykryć defekty, które nie wynikają z błędnych wymagań, ale z błędów programisty.
</p>

<p>
Zalety:
</p>

<ul>
  <li>umożliwia wykrycie defektów w logice kodu,</li>
  <li>pozwala zmierzyć rzeczywiste pokrycie kodu,</li>
  <li>pomaga wykryć pominięcia w implementacji,</li>
  <li>przydatne w przeglądach kodu i analizie pseudokodu.</li>
</ul>

<p>
Wady:
</p>

<ul>
  <li>nie wykryje brakujących wymagań (bo kod ich nie zawiera),</li>
  <li>wymaga znajomości kodu,</li>
  <li>może być czasochłonne.</li>
</ul>

<h4>Pytania testowe</h4>

<ol>
  <li>Jaka jest główna zaleta technik białoskrzynkowych?</li>
  <li>Dlaczego testowanie białoskrzynkowe może nie wykryć brakujących wymagań?</li>
  <li>Co oznacza, że pokrycie gałęzi subsumuje pokrycie instrukcji?</li>
</ol>

<h4>Odpowiedzi i wyjaśnienia</h4>

<ul>
  <li><strong>1.</strong> Pozwalają testować rzeczywistą implementację i logikę kodu.</li>
  <li><strong>2.</strong> Bo testy opierają się na kodzie, a nie na wymaganiach — jeśli czegoś nie ma w kodzie, nie zostanie przetestowane.</li>
  <li><strong>3.</strong> Jeśli masz 100% pokrycia gałęzi, automatycznie masz 100% pokrycia instrukcji.</li>
</ul>
<h2>4.4 Techniki testowania oparte na doświadczeniu</h2>

<p>
Techniki oparte na doświadczeniu wykorzystują wiedzę, intuicję i praktykę testera. 
Są szczególnie przydatne, gdy dokumentacja jest niepełna, wymagania są niejasne lub gdy trzeba szybko znaleźć defekty.
</p>

<hr>

<!-- 4.4.1 -->
<h3>4.4.1 Zgadywanie błędów</h3>

<p>
Zgadywanie błędów polega na przewidywaniu miejsc, w których mogą wystąpić defekty, 
na podstawie doświadczenia testera, typowych błędów programistów oraz wiedzy o awariach w podobnych systemach.
</p>

<p>
Typowe obszary, w których często pojawiają się błędy:
</p>

<ul>
  <li>dane wejściowe (np. brak walidacji, błędne parametry),</li>
  <li>dane wyjściowe (np. zły format, niepoprawny wynik),</li>
  <li>logika (np. brakujące przypadki, złe operatory),</li>
  <li>obliczenia (np. błędne wzory, dzielenie przez zero),</li>
  <li>interfejsy (np. niezgodność typów),</li>
  <li>dane (np. złe inicjalizacje).</li>
</ul>

<p>
Metodycznym podejściem do zgadywania błędów są tzw. <strong>ataki usterek</strong> — 
czyli tworzenie list potencjalnych błędów i projektowanie testów, które mają je ujawnić.
</p>

<h4>Przykład</h4>
<p>
Tester wie, że programiści często zapominają o obsłudze wartości ujemnych.  
Projektuje więc testy z wartościami: -1, -100, -999, aby sprawdzić, czy system je poprawnie obsłuży.
</p>

<h4>Pytania testowe</h4>
<ol>
  <li>Który obszar jest typowym źródłem błędów wykrywanych przez zgadywanie błędów?</li>
  <li>Na czym polegają ataki usterek?</li>
  <li>Co jest podstawą techniki zgadywania błędów?</li>
</ol>

<h4>Odpowiedzi ABCD</h4>
<ul>
  <li><strong>1.</strong> A: Dane wejściowe</li>
  <li><strong>2.</strong> C: Tworzeniu list potencjalnych błędów i projektowaniu testów pod nie</li>
  <li><strong>3.</strong> B: Doświadczenie i intuicja testera</li>
</ul>

<hr>

<!-- 4.4.2 -->
<h3>4.4.2 Testowanie eksploracyjne</h3>

<p>
Testowanie eksploracyjne polega na jednoczesnym projektowaniu, wykonywaniu i ocenianiu testów 
w trakcie poznawania systemu. Tester działa dynamicznie, reaguje na zachowanie aplikacji i odkrywa nowe obszary do testowania.
</p>

<p>
Często stosuje się <strong>testowanie w sesjach</strong> — tester pracuje w określonym czasie, 
ma kartę sesji z celami, a po zakończeniu odbywa się podsumowanie.
</p>

<p>
Testowanie eksploracyjne jest szczególnie przydatne, gdy:
</p>

<ul>
  <li>dokumentacja jest niepełna,</li>
  <li>czas jest ograniczony,</li>
  <li>system jest złożony i wymaga kreatywnego podejścia.</li>
</ul>

<h4>Przykład</h4>
<p>
Tester testuje nową aplikację mobilną bez szczegółowej dokumentacji.  
Przegląda ekran po ekranie, wykonuje różne akcje, zapisuje obserwacje i na bieżąco tworzy nowe testy.
</p>

<h4>Pytania testowe</h4>
<ol>
  <li>Co charakteryzuje testowanie eksploracyjne?</li>
  <li>W jakiej sytuacji testowanie eksploracyjne jest szczególnie przydatne?</li>
  <li>Co to jest testowanie w sesjach?</li>
</ol>

<h4>Odpowiedzi ABCD</h4>
<ul>
  <li><strong>1.</strong> D: Projektowanie i wykonywanie testów jednocześnie</li>
  <li><strong>2.</strong> B: Gdy dokumentacja jest niepełna lub niejasna</li>
  <li><strong>3.</strong> A: Praca w określonym czasie z kartą celów</li>
</ul>

<hr>

<!-- 4.4.3 -->
<h3>4.4.3 Testowanie w oparciu o listę kontrolną</h3>

<p>
Testowanie w oparciu o listę kontrolną polega na projektowaniu i wykonywaniu testów tak, 
aby pokryć wszystkie elementy znajdujące się na liście kontrolnej.  
Lista kontrolna może zawierać pytania, warunki testowe, wymagania lub typowe problemy.
</p>

<p>
Listy kontrolne tworzy się na podstawie:
</p>

<ul>
  <li>doświadczenia testerów,</li>
  <li>wiedzy o typowych awariach,</li>
  <li>oczekiwań użytkowników.</li>
</ul>

<p>
Listy kontrolne muszą być aktualizowane — niektóre punkty z czasem tracą skuteczność, 
a nowe defekty mogą wymagać dodania kolejnych pozycji.
</p>

<h4>Przykład</h4>
<p>
Tester ma listę kontrolną dla aplikacji webowej, np.:  
„Czy formularz waliduje e-mail?”, „Czy przycisk działa?”, „Czy strona działa na telefonie?”.  
Podczas testów odhacza każdy punkt.
</p>

<h4>Pytania testowe</h4>
<ol>
  <li>Co jest podstawą testowania w oparciu o listę kontrolną?</li>
  <li>Dlaczego listy kontrolne muszą być aktualizowane?</li>
  <li>Co może zawierać lista kontrolna?</li>
</ol>

<h4>Odpowiedzi ABCD</h4>
<ul>
  <li><strong>1.</strong> C: Lista warunków testowych do pokrycia</li>
  <li><strong>2.</strong> A: Bo niektóre punkty tracą skuteczność, a pojawiają się nowe defekty</li>
  <li><strong>3.</strong> D: Pytania, wymagania, typowe problemy</li>
</ul>
<h2>4.5 Podejścia do testowania oparte na współpracy</h2>

<p>
Techniki z poprzednich sekcji (4.2, 4.3, 4.4) skupiają się na wykrywaniu defektów. 
Podejścia oparte na współpracy koncentrują się również na <strong>zapobieganiu defektom</strong> 
poprzez komunikację, wspólne zrozumienie wymagań i współpracę między interesariuszami.
</p>

<hr>

<!-- 4.5.1 -->
<h3>4.5.1 Wspólne pisanie historyjek użytkownika</h3>

<p>
Historyjka użytkownika opisuje funkcję systemu wartościową dla użytkownika. 
Aby była zrozumiała i testowalna, stosuje się koncepcję <strong>3C</strong>:
</p>

<ul>
  <li><strong>Card</strong> – karta z opisem historyjki,</li>
  <li><strong>Conversation</strong> – rozmowa wyjaśniająca szczegóły,</li>
  <li><strong>Confirmation</strong> – kryteria akceptacji.</li>
</ul>

<p>
Najczęstszy format historyjki:
</p>

<pre>
Jako [rola] chcę [cel], aby [wartość biznesowa].
</pre>

<p>
Wspólne pisanie historyjek (biznes + programiści + testerzy) pozwala uniknąć niejasności, 
doprecyzować wymagania i upewnić się, że historyjka jest zgodna z zasadą <strong>INVEST</strong>:
</p>

<ul>
  <li>Independent</li>
  <li>Negotiable</li>
  <li>Valuable</li>
  <li>Estimable</li>
  <li>Small</li>
  <li>Testable</li>
</ul>

<h4>Przykład</h4>
<p>
Zespół tworzy historyjkę:  
„Jako klient chcę otrzymać e‑mail potwierdzający zamówienie, aby mieć dowód zakupu.”  
Tester proponuje doprecyzowanie: co jeśli e‑mail nie dojdzie? co jeśli adres jest błędny?  
Dzięki temu historyjka staje się pełniejsza i testowalna.
</p>

<h4>Pytania ABCD</h4>
<ol>
  <li>Co oznacza litera C w koncepcji 3C?</li>
  <li>Co oznacza litera T w zasadzie INVEST?</li>
  <li>Jaki jest cel wspólnego pisania historyjek użytkownika?</li>
</ol>

<h4>Odpowiedzi</h4>
<ul>
  <li><strong>1.</strong> B: Conversation</li>
  <li><strong>2.</strong> D: Testable</li>
  <li><strong>3.</strong> A: Doprecyzowanie wymagań i uniknięcie niejasności</li>
</ul>

<hr>

<!-- 4.5.2 -->
<h3>4.5.2 Kryteria akceptacji</h3>

<p>
Kryteria akceptacji to warunki, które muszą zostać spełnione, aby historyjka użytkownika została uznana za ukończoną. 
Są one traktowane jako <strong>warunki testowe</strong>.
</p>

<p>
Cele kryteriów akceptacji:
</p>

<ul>
  <li>określenie zakresu historyjki,</li>
  <li>osiągnięcie wspólnego zrozumienia,</li>
  <li>opisanie scenariuszy pozytywnych i negatywnych,</li>
  <li>podstawa do testów akceptacyjnych,</li>
  <li>ułatwienie planowania i szacowania.</li>
</ul>

<p>
Najpopularniejsze formaty:
</p>

<ul>
  <li><strong>Given / When / Then</strong> – scenariuszowy,</li>
  <li><strong>Lista reguł</strong> – tabelaryczne przypisanie wejść do wyjść.</li>
</ul>

<h4>Przykład</h4>

<p><strong>Given</strong> użytkownik jest zalogowany  
<br><strong>When</strong> dodaje produkt do koszyka  
<br><strong>Then</strong> koszyk powinien pokazać nową pozycję
</p>

<h4>Pytania ABCD</h4>
<ol>
  <li>Jaką rolę pełnią kryteria akceptacji?</li>
  <li>Który format jest scenariuszowy?</li>
  <li>Dlaczego kryteria akceptacji pomagają w planowaniu?</li>
</ol>

<h4>Odpowiedzi</h4>
<ul>
  <li><strong>1.</strong> C: Określają warunki, które muszą być spełnione</li>
  <li><strong>2.</strong> A: Given/When/Then</li>
  <li><strong>3.</strong> D: Bo precyzują zakres i oczekiwane zachowania</li>
</ul>

<hr>

<!-- 4.5.3 -->
<h3>4.5.3 Wytwarzanie sterowane testami akceptacyjnymi (ATDD)</h3>

<p>
ATDD to podejście „najpierw test”, w którym przypadki testowe tworzy się <strong>przed implementacją</strong> historyjki użytkownika.  
Testy tworzą wspólnie: klienci, programiści i testerzy.
</p>

<p>
Proces ATDD:
</p>

<ol>
  <li>warsztaty — doprecyzowanie historyjki i kryteriów akceptacji,</li>
  <li>tworzenie testów akceptacyjnych,</li>
  <li>implementacja funkcjonalności,</li>
  <li>wykonywanie testów (manualnie lub automatycznie).</li>
</ol>

<p>
Pierwsze testy są zwykle pozytywne, potem dodaje się testy negatywne i niefunkcjonalne.
</p>

<h4>Przykład</h4>
<p>
Zespół tworzy test akceptacyjny:  
„Użytkownik może zresetować hasło, jeśli poda poprawny e‑mail.”  
Dopiero potem programista implementuje funkcję resetu hasła.
</p>

<h4>Pytania ABCD</h4>
<ol>
  <li>Co jest charakterystyczne dla ATDD?</li>
  <li>Kto tworzy testy akceptacyjne w ATDD?</li>
  <li>Jakie testy tworzy się jako pierwsze?</li>
</ol>

<h4>Odpowiedzi</h4>
<ul>
  <li><strong>1.</strong> B: Testy powstają przed implementacją</li>
  <li><strong>2.</strong> C: Klienci, programiści i testerzy</li>
  <li><strong>3.</strong> A: Testy pozytywne</li>
</ul>



<h1>5.1 Planowanie testów – wersja „po ludzku”</h1>

<p>
  Ten moduł dotyczy tego, <strong>jak zaplanować testowanie</strong>: co chcemy osiągnąć,
  kto co robi, kiedy, za ile i jak sprawdzamy, że „już wystarczy testów”.
</p>

<hr />

<h2>5.1.1 Cel i treść planu testów</h2>

<p>
  <strong>Plan testów</strong> to dokument (albo zestaw ustaleń), który mówi:
</p>
<ul>
  <li>co dokładnie testujemy i po co,</li>
  <li>jak będziemy testować (podejście, poziomy, typy testów),</li>
  <li>kto jest za co odpowiedzialny,</li>
  <li>jakie zasoby są potrzebne (ludzie, środowiska, dane, narzędzia),</li>
  <li>jak wygląda harmonogram i budżet testów.</li>
</ul>

<p>Plan testów:</p>
<ul>
  <li>pomaga zaplanować <strong>jak i kiedy</strong> osiągniemy cele testów,</li>
  <li>pilnuje, żeby testy spełniały ustalone kryteria jakości,</li>
  <li>jest formą komunikacji z zespołem i interesariuszami,</li>
  <li>pokazuje, że testowanie jest spójne z polityką i strategią testów (albo świadomie od nich odbiega).</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  Tworzycie nową aplikację mobilną do zamawiania jedzenia. W planie testów zapisujecie:
  jakie funkcje są w pierwszym wydaniu (np. rejestracja, logowanie, złożenie zamówienia),
  kto testuje część mobilną, kto API, jakie środowisko testowe jest potrzebne,
  kiedy robicie testy regresji i jakie są kryteria „możemy wypuścić wersję 1.0”.
</div>

<p>Typowe elementy planu testów:</p>
<ul>
  <li><strong>Kontekst testowania:</strong> zakres, cele testów, podstawa testów (np. wymagania, user stories).</li>
  <li><strong>Założenia i ograniczenia:</strong np. „nie testujemy na IE11”, „mamy tylko jedno środowisko testowe”.</li>
  <li><strong>Interesariusze:</strong role, obowiązki, potrzeby szkoleniowe, kto podejmuje decyzje.</li>
  <li><strong>Wymiana informacji:</strong jakie raporty, jak często, w jakim formacie.</li>
  <li><strong>Rejestr ryzyk:</strong ryzyka produktowe (np. awarie) i projektowe (np. opóźnienia).</li>
  <li><strong>Podejście do testowania:</strong poziomy, typy testów, techniki, kryteria wejścia/wyjścia, metryki, dane testowe, środowisko.</li>
  <li><strong>Budżet i harmonogram:</strong ile czasu i pieniędzy przewidziano na testy.</li>
</ul>

<div class="note">
  Szczegółowy szablon planu testów opisuje standard ISO/IEC/IEEE 29119-3 – na egzaminie wystarczy znać ideę.
</div>

<hr />

<h2>5.1.2 Wkład testera w planowanie iteracji i wydań</h2>

<h3>Planowanie wydań</h3>
<p>
  <strong>Planowanie wydań</strong> patrzy szerzej – na całe wydanie produktu (np. wersja 1.0, 2.0).
  Tu ustala się backlog produktu, dzieli duże historyjki na mniejsze i określa ogólne podejście do testowania.
</p>

<p>Tester w planowaniu wydań:</p>
<ul>
  <li>pomaga pisać <strong>testowalne user stories</strong> i kryteria akceptacji,</li>
  <li>uczestniczy w analizie ryzyka (produktowego i projektowego),</li>
  <li>szacuje pracochłonność testów dla historyjek,</li>
  <li>współtworzy podejście do testowania i plan testów dla całego wydania.</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  Wydanie 2.0 ma dodać płatności kartą i PayPalem. Tester pomaga doprecyzować:
  jakie scenariusze płatności muszą być obsłużone, jakie są kryteria akceptacji
  (np. poprawne rozliczenie, obsługa błędów, zwroty), jakie ryzyka są największe
  (np. bezpieczeństwo, integracja z bramką płatniczą).
</div>

<h3>Planowanie iteracji</h3>
<p>
  <strong>Planowanie iteracji</strong> dotyczy konkretnej iteracji (sprintu) i backlogu tej iteracji.
</p>

<p>Tester w planowaniu iteracji:</p>
<ul>
  <li>analizuje szczegółowo ryzyka związane z user stories,</li>
  <li>sprawdza, czy historyjki są <strong>testowalne</strong>,</li>
  <li>dzieli historyjki na zadania testowe (np. przygotowanie danych, napisanie testów, automatyzacja),</li>
  <li>szacuje pracochłonność zadań testowych,</li>
  <li>doprecyzowuje aspekty funkcjonalne i niefunkcjonalne (np. wydajność, użyteczność).</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  W sprincie jest user story „Jako użytkownik chcę zresetować hasło”.
  Tester proponuje zadania: testy pozytywne (poprawny e‑mail), negatywne (zły e‑mail),
  testy linku resetującego, testy wygasania linku, testy bezpieczeństwa (brak ujawniania,
  czy e‑mail istnieje w systemie).
</div>

<hr />

<h2>5.1.3 Kryteria wejścia i kryteria wyjścia</h2>

<p>
  <strong>Kryteria wejścia</strong> – co musi być spełnione, żeby <em>zacząć</em> daną aktywność (np. testy systemowe).<br />
  <strong>Kryteria wyjścia</strong> – co musi być spełnione, żeby uznać, że <em>kończymy</em> daną aktywność.
</p>

<h3>Przykładowe kryteria wejścia</h3>
<ul>
  <li>dostępni ludzie, narzędzia, środowiska, dane testowe, budżet, czas,</li>
  <li>dostępna podstawa testów (wymagania, user stories),</li>
  <li>określony minimalny poziom jakości (np. przeszły testy dymne).</li>
</ul>

<h3>Przykładowe kryteria wyjścia</h3>
<ul>
  <li>osiągnięty poziom pokrycia testami,</li>
  <li>liczba otwartych defektów poniżej ustalonego progu,</li>
  <li>wykonano wszystkie zaplanowane testy,</li>
  <li>zgłoszono wszystkie wykryte defekty,</li>
  <li>zautomatyzowano wszystkie testy regresji (jeśli to cel).</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  Kryteria wejścia do testów akceptacyjnych: zakończone testy systemowe, brak defektów krytycznych,
  środowisko akceptacyjne gotowe, dane testowe przygotowane.<br />
  Kryteria wyjścia: wszystkie przypadki testowe wykonane, brak defektów o priorytecie „wysoki”,
  maksymalnie 5 defektów „średnich”, wszystkie defekty opisane i przekazane do zespołu.
</div>

<p>
  W podejściu zwinnym:
</p>
<ul>
  <li><strong>Definition of Done (DoD)</strong> – to w praktyce kryteria wyjścia dla elementu backlogu,</li>
  <li><strong>Definition of Ready (DoR)</strong> – to kryteria wejścia, żeby w ogóle zacząć pracę nad user story.</li>
</ul>

<hr />

<h2>5.1.4 Techniki szacowania</h2>

<p>
  Szacowanie pracochłonności testów to próba odpowiedzi na pytanie:
  <strong>ile pracy (czasu) potrzebujemy, żeby osiągnąć cele testów</strong>.
  Zawsze opiera się na założeniach i zawsze jest obarczone błędem.
</p>

<p>
  Dla dużych zadań lepiej jest je rozbić na mniejsze elementy – wtedy szacunki są zwykle dokładniejsze.
</p>

<h3>1. Szacowanie na podstawie proporcji</h3>
<p>
  Bazuje na danych historycznych z wcześniejszych projektów w organizacji.
  Ustalamy typowe proporcje, np. ile pracy idzie na wytwarzanie, a ile na testowanie.
</p>

<div class="example">
  <strong>Przykład:</strong><br />
  W poprzednim projekcie stosunek pracochłonności wytwarzania do testowania wyniósł 3:2.
  Jeśli w nowym projekcie wytwarzanie ma zająć 600 osobodni, to testowanie szacujemy na:
  600 × (2 / 3) = 400 osobodni.
</div>

<h3>2. Ekstrapolacja</h3>
<p>
  Zbieramy dane z bieżącego projektu jak najwcześniej, a potem
  <strong>przenosimy trend</strong> na przyszłość (często z użyciem prostego modelu matematycznego).
</p>

<div class="example">
  <strong>Przykład:</strong><br />
  W trzech ostatnich iteracjach testy zajmowały średnio 40 godzin na sprint.
  Możemy oszacować, że w kolejnym sprincie testy też zajmą około 40 godzin,
  o ile zakres i zespół są podobne.
</div>

<h3>3. Szerokopasmowa technika delficka</h3>
<p>
  Technika ekspercka, iteracyjna:
</p>
<ul>
  <li>kilku ekspertów niezależnie szacuje nakład pracy,</li>
  <li>porównuje się wyniki, omawia duże rozbieżności,</li>
  <li>eksperci ponownie szacują, już z nową wiedzą,</li>
  <li>powtarzamy, aż do osiągnięcia konsensusu.</li>
</ul>

<p>
  Wariantem jest <strong>poker planistyczny</strong> – eksperci używają kart z liczbami
  (np. ciąg Fibonacciego) i jednocześnie odkrywają swoje szacunki.
</p>

<h3>4. Szacowanie trójpunktowe</h3>
<p>
  Eksperci podają trzy wartości:
</p>
<ul>
  <li><strong>a</strong> – najbardziej optymistyczne oszacowanie,</li>
  <li><strong>m</strong> – najbardziej prawdopodobne,</li>
  <li><strong>b</strong> – najbardziej pesymistyczne.</li>
</ul>

<p>
  Następnie liczymy:
</p>
<ul>
  <li><strong>E</strong> – szacowana wartość: E = (a + 4 × m + b) / 6</li>
  <li><strong>SD</strong> – błąd (odchylenie standardowe): SD = (b – a) / 6</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  a = 6, m = 9, b = 18 (osobogodzin).<br />
  E = (6 + 4 × 9 + 18) / 6 = (6 + 36 + 18) / 6 = 60 / 6 = 10<br />
  SD = (18 – 6) / 6 = 12 / 6 = 2<br />
  Czyli szacujemy 10 ± 2 osobogodzin (od 8 do 12).
</div>

<hr />

<h2>Pytania testowe (styl ISTQB, A–D)</h2>

<div class="question">
  <p><strong>1. Jaki jest główny cel planu testów?</strong></p>
  <ul class="answers">
    <li>A. Opisanie tylko narzędzi używanych w testach.</li>
    <li>B. Udokumentowanie celów, zasobów i procesów związanych z testowaniem.</li>
    <li>C. Zastąpienie polityki testów i strategii testów.</li>
    <li>D. Opisanie wyłącznie harmonogramu wdrożenia produkcyjnego.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>2. Które z poniższych najlepiej opisuje rolę testera w planowaniu wydań?</strong></p>
  <ul class="answers">
    <li>A. Tester planuje wyłącznie testy jednostkowe.</li>
    <li>B. Tester pisze wyłącznie dokumentację użytkownika.</li>
    <li>C. Tester współtworzy testowalne user stories, kryteria akceptacji i szacuje pracochłonność testów.</li>
    <li>D. Tester decyduje samodzielnie o zakresie całego wydania.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: C</p>
</div>

<div class="question">
  <p><strong>3. Co jest przykładem kryterium wejścia do testów systemowych?</strong></p>
  <ul class="answers">
    <li>A. Wszystkie defekty zostały naprawione.</li>
    <li>B. Środowisko testowe jest dostępne i przeszły testy dymne.</li>
    <li>C. Użytkownicy końcowi zaakceptowali system.</li>
    <li>D. Zespół zakończył retrospektywę sprintu.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>4. W podejściu zwinnym „Definition of Done” odpowiada głównie:</strong></p>
  <ul class="answers">
    <li>A. Kryteriom wejścia dla projektu.</li>
    <li>B. Kryteriom wyjścia dla elementu backlogu.</li>
    <li>C. Planowi testów dla całego wydania.</li>
    <li>D. Rejestrowi ryzyk produktowych.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>5. Która technika szacowania opiera się na danych historycznych i proporcjach?</strong></p>
  <ul class="answers">
    <li>A. Ekstrapolacja.</li>
    <li>B. Szerokopasmowa technika delficka.</li>
    <li>C. Szacowanie trójpunktowe.</li>
    <li>D. Szacowanie na podstawie proporcji.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: D</p>
</div>

<div class="question">
  <p><strong>6. W szacowaniu trójpunktowym wartości a, m, b oznaczają odpowiednio:</strong></p>
  <ul class="answers">
    <li>A. Średnią, medianę i odchylenie standardowe.</li>
    <li>B. Najbardziej optymistyczne, najbardziej prawdopodobne i najbardziej pesymistyczne oszacowanie.</li>
    <li>C. Minimalny, średni i maksymalny budżet projektu.</li>
    <li>D. Liczbę defektów krytycznych, poważnych i drobnych.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>7. Które stwierdzenie o szerokopasmowej technice delfickiej jest prawdziwe?</strong></p>
  <ul class="answers">
    <li>A. Szacunki są wykonywane tylko przez jednego eksperta.</li>
    <li>B. Eksperci szacują niezależnie, a następnie iteracyjnie zbliżają się do konsensusu.</li>
    <li>C. Technika ta nie dopuszcza żadnej dyskusji między ekspertami.</li>
    <li>D. Jest to technika wyłącznie dla projektów kaskadowych.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>8. Co może być akceptowalnym kryterium wyjścia z testów?</strong></p>
  <ul class="answers">
    <li>A. Przekroczenie budżetu lub terminu, jeśli interesariusze akceptują ryzyko.</li>
    <li>B. Brak jakichkolwiek defektów w systemie.</li>
    <li>C. Wykonanie tylko testów dymnych.</li>
    <li>D. Zakończenie implementacji wszystkich funkcji bez testów.</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: A</p>
</div>

<hr />

<p class="note">
  Możesz ten plik zapisać jako <code>5_1_planowanie_testow.html</code> i otworzyć w przeglądarce.
</p>

<h2>5.1.5 Ustalanie priorytetów przypadków testowych</h2>

<p>
  Po stworzeniu przypadków testowych i zestawów testowych trzeba ustalić
  <strong>kolejność ich wykonywania</strong>. Priorytety zależą od kilku strategii.
</p>

<h3>Strategie ustalania priorytetów</h3>

<ul>
  <li><strong>Na podstawie ryzyka</strong> – pierwsze wykonujemy testy pokrywające największe ryzyka.</li>
  <li><strong>Na podstawie pokrycia</strong> – pierwsze idą testy dające największe pokrycie (np. kodu).</li>
  <li><strong>Na podstawie wymagań</strong> – kolejność wynika z priorytetów wymagań ustalonych przez interesariuszy.</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  W systemie bankowym największe ryzyko to błędne przelewy i bezpieczeństwo logowania.
  Testy tych obszarów wykonujemy jako pierwsze.
</div>

<p>
  Czasem nie da się wykonać testów dokładnie według priorytetów, np. gdy:
</p>
<ul>
  <li>test o wyższym priorytecie zależy od testu o niższym,</li>
  <li>zasoby (środowisko, narzędzia, ludzie) są dostępne tylko w określonym czasie.</li>
</ul>

<div class="example">
  <strong>Przykład zależności:</strong><br />
  Test „złożenie zamówienia” wymaga wcześniejszego przetestowania rejestracji użytkownika.
</div>

<hr />

<h2>5.1.6 Piramida testów</h2>

<p>
  <strong>Piramida testów</strong> pokazuje, że różne testy mają różną szczegółowość,
  czas wykonania i poziom izolacji.
</p>

<ul>
  <li>Na dole – <strong>testy modułowe</strong>: szybkie, tanie, liczne.</li>
  <li>Wyżej – <strong>testy integracyjne</strong>: wolniejsze, bardziej złożone.</li>
  <li>Na górze – <strong>testy end‑to‑end</strong>: najwolniejsze, obejmują szeroki zakres.</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  W modelu Cohna: testy modułowe → testy usług → testy interfejsu użytkownika.
</div>

<p>
  Idea: <strong>dużo tanich testów nisko, mało drogich testów wysoko</strong>.
</p>

<hr />

<h2>5.1.7 Kwadranty testowe</h2>

<p>
  Kwadranty testowe (Marick, Crispin) grupują testy według:
</p>
<ul>
  <li>celu: <strong>biznesowy</strong> lub <strong>technologiczny</strong>,</li>
  <li>funkcji: <strong>wspieranie zespołu</strong> lub <strong>krytyka produktu</strong>.</li>
</ul>

<h3>Q1 – cel technologiczny, wspieranie zespołu</h3>
<ul>
  <li>Testy modułowe, testy integracji modułów.</li>
  <li>Automatyczne, w CI.</li>
</ul>

<h3>Q2 – cel biznesowy, wspieranie zespołu</h3>
<ul>
  <li>Testy funkcjonalne, testy oparte na user stories, prototypy UX, testy API.</li>
  <li>Sprawdzają kryteria akceptacji.</li>
</ul>

<h3>Q3 – cel biznesowy, krytyka produktu</h3>
<ul>
  <li>Testowanie eksploracyjne, użyteczność, UAT.</li>
  <li>Manualne, nastawione na użytkownika.</li>
</ul>

<h3>Q4 – cel technologiczny, krytyka produktu</h3>
<ul>
  <li>Testy niefunkcjonalne (wydajność, bezpieczeństwo), testy dymne.</li>
  <li>Często automatyczne.</li>
</ul>

<hr />

<h2>5.2 Zarządzanie ryzykiem</h2>

<p>
  Zarządzanie ryzykiem pomaga organizacji zwiększyć szansę osiągnięcia celów
  i poprawić jakość produktów.
</p>

<p>Obejmuje:</p>
<ul>
  <li><strong>analizę ryzyka</strong> – identyfikacja i ocena,</li>
  <li><strong>kontrolę ryzyka</strong> – łagodzenie i monitorowanie.</li>
</ul>

<p>
  Jeśli testowanie opiera się na ryzyku, mówimy o
  <strong>testowaniu opartym na ryzyku</strong>.
</p>

<hr />

<h2>5.2.1 Definicja i atrybuty ryzyka</h2>

<p>
  <strong>Ryzyko</strong> to potencjalne zdarzenie, które może mieć negatywny skutek.
</p>

<p>Opisują je dwa parametry:</p>
<ul>
  <li><strong>Prawdopodobieństwo</strong> – szansa, że wystąpi.</li>
  <li><strong>Wpływ</strong> – jak duże szkody spowoduje.</li>
</ul>

<p>
  Poziom ryzyka = kombinacja prawdopodobieństwa i wpływu.
</p>

<hr />

<h2>5.2.2 Ryzyka projektowe i produktowe</h2>

<h3>Ryzyka projektowe</h3>
<p>Związane z realizacją projektu, np.:</p>
<ul>
  <li>opóźnienia, złe szacunki, cięcia budżetu,</li>
  <li>brak kompetencji, konflikty, słaba komunikacja,</li>
  <li>problemy techniczne, rozszerzanie zakresu,</li>
  <li>problemy z dostawcami.</li>
</ul>

<h3>Ryzyka produktowe</h3>
<p>Związane z jakością produktu, np.:</p>
<ul>
  <li>błędne funkcjonalności, awarie, złe obliczenia,</li>
  <li>niska wydajność, słabe UX, podatności bezpieczeństwa.</li>
</ul>

<p>Konsekwencje mogą być poważne: utrata reputacji, koszty, szkody, a nawet zagrożenie życia.</p>

<hr />

<h2>5.2.3 Analiza ryzyka produktowego</h2>

<p>
  Celem analizy ryzyka produktowego jest ustalenie:
</p>
<ul>
  <li>jakie ryzyka istnieją,</li>
  <li>jak duże są,</li>
  <li>jak wpływają na priorytety testów.</li>
</ul>

<p>
  Na tej podstawie decydujemy, co testować intensywniej, a co mniej.
</p>

<hr />

<h2>Pytania testowe (A–D)</h2>

<div class="question">
  <p><strong>1. Która strategia priorytetyzacji testów wykorzystuje analizę ryzyka?</strong></p>
  <ul class="answers">
    <li>A. Na podstawie wymagań</li>
    <li>B. Na podstawie pokrycia</li>
    <li>C. Na podstawie ryzyka</li>
    <li>D. Alfabetyczna</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: C</p>
</div>

<div class="question">
  <p><strong>2. Co przedstawia piramida testów?</strong></p>
  <ul class="answers">
    <li>A. Harmonogram testów</li>
    <li>B. Poziomy szczegółowości i automatyzacji testów</li>
    <li>C. Listę narzędzi testowych</li>
    <li>D. Kolejność wdrożeń</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>3. Który kwadrant obejmuje testy eksploracyjne?</strong></p>
  <ul class="answers">
    <li>A. Q1</li>
    <li>B. Q2</li>
    <li>C. Q3</li>
    <li>D. Q4</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: C</p>
</div>

<div class="question">
  <p><strong>4. Co jest przykładem ryzyka projektowego?</strong></p>
  <ul class="answers">
    <li>A. Błędne obliczenia w systemie</li>
    <li>B. Opóźnienia w dostarczaniu produktów pracy</li>
    <li>C. Zbyt długi czas odpowiedzi aplikacji</li>
    <li>D. Podatność na ataki</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>5. Jakie dwa parametry opisują ryzyko?</strong></p>
  <ul class="answers">
    <li>A. Koszt i czas</li>
    <li>B. Prawdopodobieństwo i wpływ</li>
    <li>C. Liczba defektów i pokrycie</li>
    <li>D. Zasięg i liczba użytkowników</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>
<h2>5.2.3 Analiza ryzyka produktowego</h2>

<p>
  Celem analizy ryzyka produktowego jest zdobycie wiedzy o ryzykach związanych z produktem
  i wykorzystanie jej do takiego zaplanowania testów, aby <strong>zminimalizować ryzyko resztkowe</strong>.
</p>

<p>
  Analizę ryzyka warto rozpocząć jak najwcześniej w cyklu wytwarzania. Obejmuje ona dwa główne kroki:
</p>

<h3>1. Identyfikacja ryzyka</h3>
<p>
  Polega na stworzeniu możliwie pełnej listy ryzyk. Interesariusze mogą korzystać z różnych technik:
</p>
<ul>
  <li>burza mózgów,</li>
  <li>warsztaty,</li>
  <li>wywiady,</li>
  <li>diagramy przyczynowo‑skutkowe.</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  Podczas warsztatu z zespołem dev + QA + biznes pojawia się lista ryzyk:
  błędne obliczenia, awarie przy dużym obciążeniu, podatności bezpieczeństwa,
  nieintuicyjny interfejs, brak obsługi błędów API.
</div>

<h3>2. Ocena ryzyka</h3>
<p>
  Ocenianie ryzyka obejmuje:
</p>
<ul>
  <li>klasyfikację ryzyk,</li>
  <li>ustalenie prawdopodobieństwa, wpływu i poziomu ryzyka,</li>
  <li>nadanie priorytetów,</li>
  <li>zaproponowanie sposobów postępowania.</li>
</ul>

<p>
  Klasyfikacja pomaga dobrać odpowiednie działania łagodzące — ryzyka z tej samej kategorii
  często można obsłużyć podobnymi metodami.
</p>

<h3>Metody oceny ryzyka</h3>
<ul>
  <li><strong>Ilościowa</strong> – poziom ryzyka = prawdopodobieństwo × wpływ.</li>
  <li><strong>Jakościowa</strong> – używa macierzy ryzyka (np. niskie/średnie/wysokie).</li>
  <li><strong>Mieszana</strong> – łączy oba podejścia.</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  Ryzyko „błędne obliczenia podatku”: prawdopodobieństwo = średnie, wpływ = bardzo wysoki.
  W macierzy ryzyka otrzymuje priorytet „krytyczne”.
</div>

<h3>Wpływ analizy ryzyka na testowanie</h3>
<p>Wyniki analizy ryzyka pomagają ustalić:</p>
<ul>
  <li>zakres testów,</li>
  <li>poziomy i typy testów,</li>
  <li>techniki testowania i wymagany poziom pokrycia,</li>
  <li>szacunki pracochłonności,</li>
  <li>priorytety testów (najpierw obszary o najwyższym ryzyku),</li>
  <li>dodatkowe działania poza testowaniem (np. przeglądy, analiza statyczna).</li>
</ul>

<hr />

<h2>5.2.4 Kontrola ryzyka produktowego</h2>

<p>
  Kontrola ryzyka obejmuje wszystkie działania podejmowane po analizie ryzyka:
  <strong>łagodzenie ryzyka</strong> oraz <strong>monitorowanie ryzyka</strong>.
</p>

<h3>Łagodzenie ryzyka</h3>
<p>
  Polega na wdrażaniu działań zaproponowanych podczas oceny ryzyka, aby obniżyć jego poziom.
</p>

<p>Przykładowe działania łagodzące poprzez testowanie:</p>
<ul>
  <li>przydzielenie testerów z odpowiednimi kompetencjami,</li>
  <li>zapewnienie odpowiedniego poziomu niezależności testowania,</li>
  <li>przeglądy i analiza statyczna,</li>
  <li>dobór właściwych technik testowania i poziomów pokrycia,</li>
  <li>wybór typów testów zgodnych z charakterystyką ryzyka (np. wydajność, bezpieczeństwo),</li>
  <li>testowanie dynamiczne, w tym regresja.</li>
</ul>

<h3>Monitorowanie ryzyka</h3>
<p>
  Celem monitorowania jest sprawdzenie, czy działania łagodzące działają,
  oraz identyfikacja nowych ryzyk.
</p>

<h3>Możliwe decyzje po analizie ryzyka</h3>
<ul>
  <li><strong>Łagodzenie</strong> – np. dodatkowe testy, przeglądy, automatyzacja.</li>
  <li><strong>Akceptacja</strong> – jeśli koszt łagodzenia jest większy niż potencjalna szkoda.</li>
  <li><strong>Przeniesienie</strong> – np. na dostawcę zewnętrznego.</li>
  <li><strong>Plany awaryjne</strong> – co robimy, jeśli ryzyko jednak wystąpi.</li>
</ul>

<div class="example">
  <strong>Przykład:</strong><br />
  Ryzyko: „awaria przy dużym obciążeniu”.  
  Działania: testy wydajnościowe, monitoring, plan awaryjny (auto‑skalowanie).
</div>

<hr />

<h2>Pytania testowe (A–D)</h2>

<div class="question">
  <p><strong>1. Co obejmuje analiza ryzyka produktowego?</strong></p>
  <ul class="answers">
    <li>A. Tylko identyfikację ryzyka</li>
    <li>B. Tylko ocenę ryzyka</li>
    <li>C. Identyfikację i ocenę ryzyka</li>
    <li>D. Wyłącznie testowanie regresji</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: C</p>
</div>

<div class="question">
  <p><strong>2. Która metoda oceny ryzyka wykorzystuje macierz ryzyka?</strong></p>
  <ul class="answers">
    <li>A. Ilościowa</li>
    <li>B. Jakościowa</li>
    <li>C. Statystyczna</li>
    <li>D. Automatyczna</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>3. Co jest przykładem działania łagodzącego ryzyko?</strong></p>
  <ul class="answers">
    <li>A. Ignorowanie ryzyka</li>
    <li>B. Dobór odpowiednich technik testowania</li>
    <li>C. Zmiana nazwy projektu</li>
    <li>D. Zmniejszenie liczby testerów</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>4. Co jest celem monitorowania ryzyka?</strong></p>
  <ul class="answers">
    <li>A. Zwiększenie liczby defektów</li>
    <li>B. Sprawdzenie skuteczności działań łagodzących i wykrycie nowych ryzyk</li>
    <li>C. Zastąpienie testów manualnych automatyzacją</li>
    <li>D. Zmiana priorytetów wymagań</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: B</p>
</div>

<div class="question">
  <p><strong>5. Który wariant NIE należy do kontroli ryzyka?</strong></p>
  <ul class="answers">
    <li>A. Akceptacja ryzyka</li>
    <li>B. Przeniesienie ryzyka</li>
    <li>C. Plany awaryjne</li>
    <li>D. Zwiększenie liczby błędów w systemie</li>
  </ul>
  <p class="correct">Poprawna odpowiedź: D</p>
</div>


</div>
</script>
    <script src="/navigation.js"></script>
<script src="/main.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>
</body>
</html>
